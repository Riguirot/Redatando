This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.env.exemple
.gitignore
ARCHITECTURE.md
estrutura.txt
jest.config.ts
package.json
prisma.config.ts
prisma/migrations/20260127014313_create_content/migration.sql
prisma/migrations/20260201152427_add_credit_transactions/migration.sql
prisma/migrations/20260201153641_add_essay_table/migration.sql
prisma/migrations/migration_lock.toml
prisma/schema.prisma
ROADMAP.md
src/@types/express/index.d.ts
src/app.ts
src/modules/credits/application/useCases/__tests__/CheckUserCreditsUseCase.spec.ts
src/modules/credits/application/useCases/AddCreditsUseCase.ts
src/modules/credits/application/useCases/CheckUserCreditsUseCase.ts
src/modules/credits/application/useCases/RemoveCreditsUseCase.ts
src/modules/credits/application/useCases/ToggleInfiniteCreditsUseCase.ts
src/modules/credits/domain/entities/CreditTransaction.ts
src/modules/credits/domain/errors/CreditBlockedError.ts
src/modules/credits/domain/services/__tests__/CreditPolicyService.spec.ts
src/modules/credits/domain/services/CreditPolicyService.ts
src/modules/credits/infra/database/PrismaCreditRepository.ts
src/modules/credits/ports/CreditRepository.ts
src/modules/credits/presentation/controllers/CreditAdminController.ts
src/modules/credits/presentation/routes.ts
src/modules/essays/application/useCases/__tests__/GetEssayByIdUseCase.spec.ts
src/modules/essays/application/useCases/GetEssayByIdUseCase.ts
src/modules/essays/application/useCases/ListStudentEssaysUseCase.ts
src/modules/essays/application/useCases/SubmitEssayUseCase.ts
src/modules/essays/domain/entities/Essay.ts
src/modules/essays/domain/errors/EssayNotFoundError.ts
src/modules/essays/domain/services/WeeklyLimitService.ts
src/modules/essays/domain/valueObjects/EssayStatus.ts
src/modules/essays/dtos/EssayDetailsDTO.ts
src/modules/essays/dtos/EssayListItemDTO.ts
src/modules/essays/dtos/EssayResponseDTO.ts
src/modules/essays/dtos/SubmitEssayDTO.ts
src/modules/essays/infra/database/PrismaEssayRepository.ts
src/modules/essays/infra/mappers/__tests__/EssayMapper.spec.ts
src/modules/essays/infra/mappers/EssayMapper.ts
src/modules/essays/infra/storage/LocalStorageService.ts
src/modules/essays/infra/storage/S3StorageService.ts
src/modules/essays/ports/EssayRepository.ts
src/modules/essays/ports/StorageService.ts
src/modules/essays/presentation/controllers/EssayController.ts
src/modules/essays/presentation/index.ts
src/modules/essays/presentation/middlewares/idempotency.middleware.ts
src/modules/essays/presentation/middlewares/validateSubmitEssay.middleware.ts.ts
src/modules/essays/presentation/routes.ts
src/modules/health/application/CheckHealthUseCase.ts
src/modules/health/presentation/controllers/HealthController.ts
src/modules/health/presentation/routes.ts
src/modules/shared/config/cors.ts
src/modules/shared/config/env.ts
src/modules/shared/config/helmet.ts
src/modules/shared/config/logger.ts
src/modules/shared/database/prismaClient.ts
src/modules/shared/errors/AppError.ts
src/modules/shared/errors/BusinessError.ts
src/modules/shared/errors/ValidationError.ts
src/modules/shared/http/middlewares/error.middleware.ts
src/modules/shared/http/middlewares/rateLimit.middleware.ts
src/modules/shared/http/middlewares/validation.middleware.ts
src/modules/shared/http/response.ts
src/modules/shared/transactions/PrismaTransactionManager.ts
src/modules/shared/transactions/TransactionManager.ts
src/modules/shared/utils/sanitize.ts
src/modules/users/domain/entities/Student.ts
src/modules/users/infra/database/PrismaStudentRepository.ts
src/modules/users/ports/StudentRepository.ts
src/routes/index.ts
src/server.ts
src/tests/e2e/submit-essay.e2e.spec.ts
src/tests/integration/credits.routes.spec.ts
src/tests/integration/essays.routes.spec.ts
src/tests/unit/credits/AddCreditsUseCase.spec.ts
src/tests/unit/essays/SubmitEssayUseCase.spec.ts
storage/test-student-1-1769964679943.pdf
TASK.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/modules/essays/domain/errors/EssayNotFoundError.ts">
export class EssayNotFoundError extends Error {
  constructor(essayId: string) {
    super(`Essay with id ${essayId} not found`)
    this.name = 'EssayNotFoundError'
  }
}
</file>

<file path=".env.exemple">
# ===============================
# Server
# ===============================
PORT=3000
NODE_ENV=development

# ===============================
# Application
# ===============================
APP_NAME=redatando
APP_VERSION=1.0.0

# ===============================
# Security
# ===============================
RATE_LIMIT_WINDOW_MINUTES=15
RATE_LIMIT_MAX_REQUESTS=100

# ===============================
# CORS
# ===============================
CORS_ORIGIN=http://localhost:3000

# ===============================
# Logging
# ===============================
LOG_LEVEL=info

# ===============================
# Future use (do not use yet)
# ===============================
# JWT_SECRET=
# JWT_EXPIRES_IN=
</file>

<file path="ARCHITECTURE.md">
# üèóÔ∏è ARCHITECTURE ‚Äî REDATANDO (Backend)

Este documento descreve a arquitetura do backend do sistema web de
**corre√ß√£o de reda√ß√µes da Redatando**.

A arquitetura foi projetada para crescer de forma incremental,
seguindo rigorosamente o roadmap definido, mantendo seguran√ßa,
clareza e padr√£o profissional desde o primeiro commit.

---

## üéØ ESCOPO ATUAL

Esta arquitetura cobre oficialmente:

- üß± FASE 0 ‚Äî Prepara√ß√£o
- üîê FASE 1 ‚Äî Seguran√ßa estrutural
- üß© FASE 2 ‚Äî Base da API (Contrato)

Funcionalidades como banco de dados, upload de imagens e autentica√ß√£o
completa **n√£o fazem parte deste documento ainda** e ser√£o adicionadas
nas pr√≥ximas fases sem quebra estrutural.

---

## üß± VIS√ÉO GERAL DA ARQUITETURA

Fluxo padr√£o de uma requisi√ß√£o HTTP:

Client
‚Üì
Middlewares globais
‚Üì
Controller
‚Üì
Service
‚Üì
Response padronizada


Princ√≠pios:
- Controllers n√£o cont√™m regra de neg√≥cio
- Services concentram a l√≥gica da aplica√ß√£o
- Middlewares cuidam de seguran√ßa, valida√ß√£o e erros
- A API sempre responde no mesmo formato

---

## üì¶ ESTRUTURA DE PASTAS (ATUAL)

redatando/
‚îú‚îÄ‚îÄ src/
‚îÇ ‚îú‚îÄ‚îÄ app.ts
‚îÇ ‚îú‚îÄ‚îÄ server.ts
‚îÇ ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ config/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ env.ts
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ cors.ts
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ helmet.ts
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ logger.ts
‚îÇ ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ shared/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ errors/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ AppError.ts
‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ middlewares/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ error.middleware.ts
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ rateLimit.middleware.ts
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ validation.middleware.ts
‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ http/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ response.ts
‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ utils/
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ sanitize.ts
‚îÇ ‚îÇ
‚îÇ ‚îú‚îÄ‚îÄ modules/
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ health/
‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ HealthController.ts
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ routes.ts
‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ content/
‚îÇ ‚îÇ ‚îÇ  ‚îî‚îÄ‚îÄ repositories/    --> feacture futura
‚îÇ ‚îÇ ‚îÇ  ‚îî‚îÄ‚îÄ entities/        --> feacture futura
‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ controllers/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ContentController.ts
‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ services/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ ContentService.ts
‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ dtos/
‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ CreateContentDTO.ts
‚îÇ ‚îÇ ‚îÇ
‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ routes.ts
‚îÇ ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ routes/
‚îÇ ‚îî‚îÄ‚îÄ index.ts
‚îÇ
‚îú‚îÄ‚îÄ tests/
‚îÇ ‚îú‚îÄ‚îÄ unit/
‚îÇ ‚îî‚îÄ‚îÄ integration/
‚îÇ
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ jest.config.ts
‚îî‚îÄ‚îÄ package.json


---

## üß© RESPONSABILIDADES DAS CAMADAS

### `app.ts`
- Inicializa o Express
- Aplica middlewares globais
- Registra as rotas

---

### `server.ts`
- Respons√°vel apenas por subir o servidor
- Separado para facilitar testes automatizados

---

### `config/`
Configura√ß√µes isoladas da aplica√ß√£o:
- `env.ts` ‚Üí carregamento e valida√ß√£o de vari√°veis de ambiente
- `cors.ts` ‚Üí pol√≠tica de CORS
- `helmet.ts` ‚Üí headers de seguran√ßa
- `logger.ts` ‚Üí logging b√°sico

---

### `shared/errors`
- Classe base `AppError`
- Centraliza mensagens e status HTTP
- Evita exposi√ß√£o de stack trace ao cliente

---

### `shared/middlewares`

- `error.middleware.ts`
  - Tratamento centralizado de erros
- `rateLimit.middleware.ts`
  - Prote√ß√£o contra abuso de requisi√ß√µes
- `validation.middleware.ts`
  - Bloqueia payload inv√°lido antes do controller

---

### `shared/http/response.ts`

Todas as respostas da API seguem o mesmo padr√£o:

```json
{
  "success": true,
  "data": {},
  "error": null
}

Ou, em caso de erro:

{
  "success": false,
  "data": null,
  "error": {
    "message": "Mensagem clara para o cliente",
    "code": "ERROR_CODE"
  }
}

|---modules/


Cada m√≥dulo representa um dom√≠nio isolado da aplica√ß√£o.

Regras:

Um m√≥dulo n√£o acessa diretamente outro m√≥dulo

Toda l√≥gica fica concentrada no service

Controllers apenas orquestram a entrada e sa√≠da HTTP


|---controllers/


Recebem req e res

Chamam os services

Nunca cont√™m regra de neg√≥cio


|---services/


Implementam as regras da aplica√ß√£o

Orquestram fluxos

Centralizam decis√µes


|---dtos/


Definem contratos de entrada

Garantem valida√ß√£o e previsibilidade da API

routes.ts

Apenas mapeamento de rotas

Nenhuma l√≥gica de neg√≥cio


üîê SEGURAN√áA (FASE 1)

Seguran√ßa aplicada desde o in√≠cio:

Helmet para headers seguros

CORS configurado

Rate limit global

Sanitiza√ß√£o de input

Middleware centralizado de erro

Logger b√°sico


üß™ TESTES (ESTRUTURA PREPARADA)

A estrutura j√° suporta:

Testes unit√°rios de services

Testes de integra√ß√£o de rotas

Evolu√ß√£o sem refatora√ß√£o estrutural


üöÄ EVOLU√á√ÉO PLANEJADA

Esta arquitetura evoluir√° de forma incremental para suportar:

Persist√™ncia em banco de dados (FASE 3)

Upload e gest√£o de imagens (FASE 4)

Autentica√ß√£o e roles (FASE 6)

Sem quebra de contratos nem retrabalho.


‚úÖ PRINC√çPIOS ADOTADOS

Simplicidade acima de complexidade

Seguran√ßa antes de feature

Contrato de API como base

C√≥digo explic√°vel em entrevista

Crescimento faseado e consciente
</file>

<file path="prisma/migrations/20260127014313_create_content/migration.sql">
-- CreateTable
CREATE TABLE "Content" (
    "id" TEXT NOT NULL,
    "title" TEXT NOT NULL,
    "text" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Content_pkey" PRIMARY KEY ("id")
);
</file>

<file path="prisma/migrations/20260201152427_add_credit_transactions/migration.sql">
-- CreateTable
CREATE TABLE "CreditTransaction" (
    "id" TEXT NOT NULL,
    "userId" TEXT NOT NULL,
    "type" TEXT NOT NULL,
    "amount" INTEGER NOT NULL,
    "description" TEXT,
    "expiresAt" TIMESTAMP(3),
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "CreditTransaction_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "CreditTransaction_userId_idx" ON "CreditTransaction"("userId");
</file>

<file path="prisma/migrations/20260201153641_add_essay_table/migration.sql">
-- CreateTable
CREATE TABLE "Essay" (
    "id" TEXT NOT NULL,
    "studentId" TEXT NOT NULL,
    "theme" TEXT NOT NULL,
    "fileUrl" TEXT NOT NULL,
    "status" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Essay_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "Essay_studentId_idx" ON "Essay"("studentId");
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="src/@types/express/index.d.ts">
import 'express'

declare global {
  namespace Express {
    interface Request {
      file?: {
        fieldname: string
        originalname: string
        encoding: string
        mimetype: string
        size: number
        buffer: Buffer
      }
    }
  }
}

export {}
</file>

<file path="src/modules/credits/application/useCases/__tests__/CheckUserCreditsUseCase.spec.ts">
import { CheckUserCreditsUseCase } from '../CheckUserCreditsUseCase'
import { CreditPolicyService } from '../../../domain/services/CreditPolicyService'
import { BusinessError } from '../../../../shared/errors/BusinessError'
import { CreditRepository } from '../../../ports/CreditRepository'

const mockCreditRepository = (): CreditRepository =>
  ({
    getUserCreditStatus: jest.fn(),
  } as unknown as CreditRepository)

describe('CheckUserCreditsUseCase', () => {
  it('deve permitir quando cr√©ditos s√£o v√°lidos', async () => {
    const repo = mockCreditRepository()
    const service = new CreditPolicyService()
    const useCase = new CheckUserCreditsUseCase(
      repo,
      service
    )

    ;(
      repo.getUserCreditStatus as jest.Mock
    ).mockResolvedValue({
      availableCredits: 3,
      creditExpirationDate: null,
    })

    const result = await useCase.execute({
      userId: 'user-1',
      planActive: true,
    })

    expect(result.allowed).toBe(true)
  })

  it('deve lan√ßar erro quando saldo √© insuficiente', async () => {
    const repo = mockCreditRepository()
    const service = new CreditPolicyService()
    const useCase = new CheckUserCreditsUseCase(
      repo,
      service
    )

    ;(
      repo.getUserCreditStatus as jest.Mock
    ).mockResolvedValue({
      availableCredits: 0,
      creditExpirationDate: null,
    })

    await expect(
      useCase.execute({
        userId: 'user-1',
        planActive: true,
      })
    ).rejects.toBeInstanceOf(BusinessError)
  })
})
</file>

<file path="src/modules/credits/application/useCases/AddCreditsUseCase.ts">

</file>

<file path="src/modules/credits/application/useCases/RemoveCreditsUseCase.ts">

</file>

<file path="src/modules/credits/application/useCases/ToggleInfiniteCreditsUseCase.ts">

</file>

<file path="src/modules/credits/domain/errors/CreditBlockedError.ts">
import { CreditBlockReason } from '../services/CreditPolicyService'

export class CreditBlockedError extends Error {
  constructor(
    public readonly reason: CreditBlockReason,
    message: string
  ) {
    super(message)
    this.name = 'CreditBlockedError'
  }
}
</file>

<file path="src/modules/credits/domain/services/__tests__/CreditPolicyService.spec.ts">
import {
  CreditPolicyService,
  CreditBlockReason,
} from '../CreditPolicyService'

describe('CreditPolicyService', () => {
  const service = new CreditPolicyService()

  it('deve bloquear quando o plano est√° inativo', () => {
    const result = service.evaluate({
      availableCredits: 10,
      creditExpirationDate: null,
      planActive: false,
    })

    expect(result.allowed).toBe(false)
    if (!result.allowed) {
      expect(result.reason).toBe(
        CreditBlockReason.PLAN_INACTIVE
      )
    }
  })

  it('deve bloquear quando cr√©ditos est√£o expirados', () => {
    const result = service.evaluate({
      availableCredits: 10,
      creditExpirationDate: new Date('2020-01-01'),
      planActive: true,
    })

    expect(result.allowed).toBe(false)
    if (!result.allowed) {
      expect(result.reason).toBe(
        CreditBlockReason.CREDITS_EXPIRED
      )
    }
  })

  it('deve bloquear quando saldo √© insuficiente', () => {
    const result = service.evaluate({
      availableCredits: 0,
      creditExpirationDate: null,
      planActive: true,
    })

    expect(result.allowed).toBe(false)
    if (!result.allowed) {
      expect(result.reason).toBe(
        CreditBlockReason.INSUFFICIENT_CREDITS
      )
    }
  })

  it('deve permitir quando tudo est√° v√°lido', () => {
    const result = service.evaluate({
      availableCredits: 5,
      creditExpirationDate: null,
      planActive: true,
    })

    expect(result.allowed).toBe(true)
  })
})
</file>

<file path="src/modules/credits/presentation/controllers/CreditAdminController.ts">

</file>

<file path="src/modules/credits/presentation/routes.ts">

</file>

<file path="src/modules/essays/application/useCases/__tests__/GetEssayByIdUseCase.spec.ts">
import { GetEssayByIdUseCase } from '../GetEssayByIdUseCase'
import { Essay } from '../../../domain/entities/Essay'
import { EssayRepository } from '../../../ports/EssayRepository'
import { EssayStatus } from '../../../domain/valueObjects/EssayStatus'
import { BusinessError } from '../../../../shared/errors/BusinessError'

class EssayRepositoryStub implements EssayRepository {
  findById = jest.fn<Promise<Essay | null>, [string]>()

  findByStudent = jest.fn<
    Promise<{ items: Essay[]; total: number }>,
    [{
      studentId: string
      page: number
      limit: number
      status?: EssayStatus
    }]
  >()

  save = jest.fn<Promise<Essay>, [Essay]>()
}

const makeEssay = (studentId: string) =>
  Essay.restore(
    {
      theme: 'Tema teste',
      fileUrl: 'file.pdf',
      studentId,
    },
    'essay-id-123',
    EssayStatus.SUBMITTED,
    new Date()
  )


describe('GetEssayByIdUseCase', () => {
  let repository: EssayRepositoryStub
  let useCase: GetEssayByIdUseCase

  beforeEach(() => {
    repository = new EssayRepositoryStub()
    useCase = new GetEssayByIdUseCase(repository)
  })

  it('should return essay details when essay exists', async () => {
    repository.findById.mockResolvedValue(makeEssay('student-id-1'))

    const result = await useCase.execute({
      essayId: 'essay-id-123',
      studentId: 'student-id-1',
    })

    expect(result.id).toBe('essay-id-123')
    expect(result.theme).toBe('Tema teste')
  })

  it('should throw BusinessError if essay does not exist', async () => {
    repository.findById.mockResolvedValue(null)

    await expect(
      useCase.execute({
        essayId: 'invalid-id',
        studentId: 'student-id-1',
      })
    ).rejects.toBeInstanceOf(BusinessError)
  })
})
</file>

<file path="src/modules/essays/application/useCases/ListStudentEssaysUseCase.ts">
import { EssayRepository } from '../../ports/EssayRepository'
import { EssayStatus } from '../../domain/valueObjects/EssayStatus'
import { EssayListItemDTO } from '../../dtos/EssayListItemDTO'

type ListStudentEssaysInput = {
  studentId: string
  page: number
  limit: number
  status?: EssayStatus
}

type ListStudentEssaysOutput = {
  total: number
  items: EssayListItemDTO[]
}

export class ListStudentEssaysUseCase {
  constructor(
    private readonly essayRepository: EssayRepository
  ) {}

  async execute(
    input: ListStudentEssaysInput
  ): Promise<ListStudentEssaysOutput> {
    const { studentId, page, limit, status } = input

    const { items, total } =
      await this.essayRepository.findByStudent({
        studentId,
        page,
        limit,
        status,
      })

    return {
      total,
      items: items.map((essay) => ({
        id: essay.getIdOrThrow(),
        theme: essay.getTheme(),
        status: essay.getStatus(),
        createdAt: essay.getCreatedAt(),
      })),
    }
  }
}
</file>

<file path="src/modules/essays/domain/services/WeeklyLimitService.ts">

</file>

<file path="src/modules/essays/dtos/EssayDetailsDTO.ts">
import { EssayStatus } from '../domain/valueObjects/EssayStatus'

export type EssayDetailsDTO = {
  id: string
  theme: string
  status: EssayStatus
  fileUrl: string
  createdAt: Date
}
</file>

<file path="src/modules/essays/dtos/EssayListItemDTO.ts">
import { EssayStatus } from '../domain/valueObjects/EssayStatus'

export type EssayListItemDTO = {
  id: string
  theme: string
  status: EssayStatus
  createdAt: Date
}
</file>

<file path="src/modules/essays/infra/mappers/__tests__/EssayMapper.spec.ts">
import { EssayMapper } from '../EssayMapper'
import { Essay } from '../../../domain/entities/Essay'
import { EssayStatus } from '../../../domain/valueObjects/EssayStatus'

describe('EssayMapper', () => {
  it('should map Essay entity to EssayDetailsDTO', () => {
    const essay = Essay.restore(
      {
          theme: 'Tema ENEM',
          fileUrl: 'https://file.url/essay.pdf',
          studentId: ''
      },
      'essay-id-123',
      EssayStatus.SUBMITTED,
      new Date('2025-01-01')
    )

    const dto = EssayMapper.toDetailsDTO(essay)

    expect(dto).toEqual({
      id: 'essay-id-123',
      theme: 'Tema ENEM',
      status: EssayStatus.SUBMITTED,
      fileUrl: 'https://file.url/essay.pdf',
      createdAt: essay.getCreatedAt(),
    })
  })

  it('should throw if essay has no id', () => {
    const essay = Essay.create({
        theme: 'Tema inv√°lido',
        fileUrl: 'file.pdf',
        studentId: ''
    })

    expect(() => {
      EssayMapper.toDetailsDTO(essay)
    }).toThrow()
  })
})
</file>

<file path="src/modules/essays/infra/storage/S3StorageService.ts">

</file>

<file path="src/modules/essays/presentation/middlewares/idempotency.middleware.ts">

</file>

<file path="src/modules/essays/presentation/middlewares/validateSubmitEssay.middleware.ts.ts">
import { Request, Response, NextFunction } from "express";
import { AppError } from "../../../shared/errors/AppError";
import { CreateContentDTO } from "../../dtos/SubmitEssayDTO";

export function validateCreateContent(
  req: Request,
  res: Response,
  next: NextFunction
) {
  const body = req.body as Partial<CreateContentDTO>;

  if (!body.title || typeof body.title !== "string") {
    throw new AppError("Title is required", 400, "VALIDATION_ERROR");
  }

  if (!body.text || typeof body.text !== "string") {
    throw new AppError("Text is required", 400, "VALIDATION_ERROR");
  }

  next();
}
</file>

<file path="src/modules/health/application/CheckHealthUseCase.ts">

</file>

<file path="src/modules/health/presentation/routes.ts">
import { Router } from "express";
import { HealthController } from "./controllers/HealthController";

const router = Router();

router.get("/health", HealthController.check);

export default router;
</file>

<file path="src/modules/shared/config/cors.ts">

</file>

<file path="src/modules/shared/config/env.ts">
import dotenv from "dotenv";

dotenv.config();

function required(key: string): string {
  const value = process.env[key];
  if (!value) {
    throw new Error(`‚ùå Environment variable ${key} is required`);
  }
  return value;
}

export const env = {
  PORT: Number(process.env.PORT) || 3000,
  NODE_ENV: process.env.NODE_ENV || "development",

  APP_NAME: process.env.APP_NAME || "redatando",
  APP_VERSION: process.env.APP_VERSION || "1.0.0",

  RATE_LIMIT_WINDOW_MINUTES: Number(
    process.env.RATE_LIMIT_WINDOW_MINUTES || 15
  ),
  RATE_LIMIT_MAX_REQUESTS: Number(
    process.env.RATE_LIMIT_MAX_REQUESTS || 100
  ),

  CORS_ORIGIN: process.env.CORS_ORIGIN || "*",

  LOG_LEVEL: process.env.LOG_LEVEL || "info"
};
</file>

<file path="src/modules/shared/config/helmet.ts">

</file>

<file path="src/modules/shared/config/logger.ts">

</file>

<file path="src/modules/shared/errors/AppError.ts">
export class AppError extends Error {
  public readonly statusCode: number;
  public readonly code: string;

  constructor(
    message: string,
    statusCode: number = 400,
    code: string = "APP_ERROR"
  ) {
    super(message);

    this.statusCode = statusCode;
    this.code = code;

    Object.setPrototypeOf(this, AppError.prototype);
  }
}
</file>

<file path="src/modules/shared/errors/ValidationError.ts">

</file>

<file path="src/modules/shared/http/middlewares/rateLimit.middleware.ts">
import rateLimit from "express-rate-limit";
import { env } from "../../config/env";

export const rateLimitMiddleware = rateLimit({
  windowMs: env.RATE_LIMIT_WINDOW_MINUTES * 60 * 1000,
  max: env.RATE_LIMIT_MAX_REQUESTS,
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    success: false,
    data: null,
    error: {
      message: "Too many requests, please try again later",
      code: "RATE_LIMIT_EXCEEDED"
    }
  }
});
</file>

<file path="src/modules/shared/http/middlewares/validation.middleware.ts">
import { Request, Response, NextFunction } from "express";

export function sanitizeMiddleware(
  req: Request,
  res: Response,
  next: NextFunction
) {
  if (req.body && typeof req.body === "object") {
    Object.keys(req.body).forEach((key) => {
      if (typeof req.body[key] === "string") {
        req.body[key] = req.body[key].trim();
      }
    });
  }

  next();
}
</file>

<file path="src/modules/shared/http/response.ts">
import { Response } from "express";

interface ErrorPayload {
  message: string;
  code?: string;
}

export function successResponse<T>(
  res: Response,
  data: T,
  statusCode = 200
) {
  return res.status(statusCode).json({
    success: true,
    data,
    error: null
  });
}

export function errorResponse(
  res: Response,
  error: ErrorPayload,
  statusCode = 400
) {
  return res.status(statusCode).json({
    success: false,
    data: null,
    error
  });
}
</file>

<file path="src/modules/shared/transactions/PrismaTransactionManager.ts">
import { prisma } from '../database/prismaClient'
import { TransactionManager } from './TransactionManager'

export class PrismaTransactionManager implements TransactionManager {
  async run<T>(callback: () => Promise<T>): Promise<T> {
    return prisma.$transaction(async () => {
      return callback()
    })
  }
}
</file>

<file path="src/modules/shared/utils/sanitize.ts">

</file>

<file path="src/modules/users/domain/entities/Student.ts">

</file>

<file path="src/modules/users/infra/database/PrismaStudentRepository.ts">

</file>

<file path="src/modules/users/ports/StudentRepository.ts">

</file>

<file path="src/tests/e2e/submit-essay.e2e.spec.ts">
describe('SubmitEssayUseCase', () => {
  it('dummy test (placeholder)', () => {
    expect(true).toBe(true)
  })
})
</file>

<file path="TASK.md">
üîπ TASK 0 ‚Äî Prepara√ß√£o m√≠nima (j√° praticamente feita)


üìå Objetivo: base est√°vel

Arquivos

shared/errors/*.ts

shared/transactions/TransactionManager.ts

Reposit√≥rios Prisma (estrutura, mesmo vazios)

Estado

Use cases ainda vazios

Projeto compila

Testes rodam (mesmo falhando)

‚úÖ SEM TESTE obrigat√≥rio aqui
(√© setup)




üîπ TASK 1 ‚Äî Dom√≠nio de Cr√©ditos (isolado)


üìå Objetivo: garantir regra de monetiza√ß√£o

Implementar

credits/domain/entities/CreditTransaction.ts

credits/domain/services/CreditPolicyService.ts

Regra m√≠nima

cr√©dito infinito

saldo suficiente / insuficiente

Teste obrigat√≥rio

üìÑ tests/unit/credits/AddCreditsUseCase.spec.ts

üëâ Mesmo sem use case completo, voc√™ j√° testa o servi√ßo de dom√≠nio.




üîπ TASK 2 ‚Äî Use case de cr√©ditos (admin)


üìå Objetivo: entrada administrativa

Implementar

AddCreditsUseCase.ts

RemoveCreditsUseCase.ts

ToggleInfiniteCreditsUseCase.ts

Teste obrigat√≥rio

üìÑ tests/unit/credits/AddCreditsUseCase.spec.ts
(agora completo, com mocks)

üëâ Se isso falhar, nada mais importa ainda.




üîπ TASK 3 ‚Äî Dom√≠nio de Reda√ß√£o (essays)


üìå Objetivo: regra pura

Implementar

essays/domain/entities/Essay.ts

essays/domain/valueObjects/EssayStatus.ts

essays/domain/services/WeeklyLimitService.ts

Teste obrigat√≥rio

üìÑ tests/unit/essays/SubmitEssayUseCase.spec.ts
(s√≥ testando limite semanal, sem infra)




üîπ TASK 4 ‚Äî Storage abstrato


üìå Objetivo: n√£o acoplar infra

Implementar

ports/StorageService.ts

infra/storage/LocalStorageService.ts

‚ö†Ô∏è Sem l√≥gica de neg√≥cio aqui

Teste obrigat√≥rio

üìÑ Teste unit√°rio simples do LocalStorage (opcional)
(pode at√© pular no MVP)



üîπ TASK 5 ‚Äî SubmitEssayUseCase (n√∫cleo do sistema)


üìå Objetivo: cora√ß√£o do produto

Implementar (ordem interna)

Valida limite semanal

Valida cr√©dito

Upload do PDF

Transa√ß√£o:

salvar reda√ß√£o

debitar cr√©dito

Rollback compensat√≥rio se falhar

Arquivos

SubmitEssayUseCase.ts

EssayRepository.ts

StorageService.ts

Teste obrigat√≥rio (CR√çTICO)

üìÑ tests/unit/essays/SubmitEssayUseCase.spec.ts

üëâ Esse teste precisa cobrir:

sucesso

sem cr√©dito

limite semanal estourado

falha no storage

rollback funcionando



üîπ TASK 6 ‚Äî Controllers + Middlewares

üìå Objetivo: entrada HTTP segura

Implementar

EssayController.ts

validateSubmitEssay.middleware.ts

idempotency.middleware.ts

Teste obrigat√≥rio

üìÑ tests/integration/essays.routes.spec.ts

üëâ Aqui voc√™ valida:

status HTTP correto

erro amig√°vel

duplica√ß√£o bloqueada



üîπ TASK 7 ‚Äî Rotas + Health


üìå Objetivo: API utiliz√°vel

Implementar

routes.ts

routes/index.ts

Health j√° existe (ok)

Teste obrigat√≥rio

üìÑ Health endpoint (simples)



üîπ TASK 8 ‚Äî Integra√ß√£o de Cr√©ditos


üìå Objetivo: admin real

Implementar

CreditAdminController.ts

rotas protegidas

Teste obrigat√≥rio

üìÑ tests/integration/credits.routes.spec.ts



üîπ TASK 9 ‚Äî Refinos finais


üìå Objetivo: produto apresent√°vel

Mensagens de erro

Logs

DTO de resposta

README t√©cnico

‚úÖ Testes j√° cobrem tudo aqui
</file>

<file path=".gitignore">
# Node
node_modules/

# Build
dist/

# Environment variables
.env

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Coverage
coverage/

# IDE / Editor
.vscode/
.idea/

# OS
.DS_Store
Thumbs.db

/src/generated/prisma
</file>

<file path="jest.config.ts">
import type { Config } from 'jest'

const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'node',

  // üëá S√≥ onde existe teste real agora
  roots: ['<rootDir>/src/modules', '<rootDir>/src/tests'], 

  moduleFileExtensions: ['ts', 'js', 'json'],

  testMatch: ['**/*.spec.ts'],

  clearMocks: true,
  collectCoverage: false,

  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
  },

  setupFilesAfterEnv: [],
}

export default config
</file>

<file path="prisma.config.ts">
import 'dotenv/config'
import { defineConfig } from 'prisma/config'

export default defineConfig({
  datasource: {
    url: process.env.DATABASE_URL!,
  },
})
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model Content {
  id        String   @id @default(uuid())
  title     String
  text      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CreditTransaction {
  id          String   @id @default(uuid())
  userId      String
  type        String
  amount      Int
  description String?
  expiresAt   DateTime?
  createdAt   DateTime @default(now())

  @@index([userId])
}

model Essay {
  id        String   @id @default(uuid())
  studentId String
  theme     String
  fileUrl   String
  status    String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([studentId])
}
</file>

<file path="src/modules/credits/application/useCases/CheckUserCreditsUseCase.ts">
import { CreditPolicyService } from '../../domain/services/CreditPolicyService'
import { CreditRepository } from '../../ports/CreditRepository'
import { BusinessError } from '../../../shared/errors/BusinessError'

type CheckUserCreditsInput = {
  userId: string
  planActive: boolean
}

type CheckUserCreditsOutput = {
  allowed: true
}

export class CheckUserCreditsUseCase {
  constructor(
    private readonly creditRepository: CreditRepository,
    private readonly creditPolicyService: CreditPolicyService
  ) {}

  async execute(
    input: CheckUserCreditsInput
  ): Promise<CheckUserCreditsOutput> {
    const { userId, planActive } = input

    const {
  availableCredits,
  creditExpirationDate,
} = await this.creditRepository.getUserCreditStatus(userId)

const policyResult = this.creditPolicyService.evaluate({
  availableCredits,
  creditExpirationDate,
  planActive,
})

    if (!policyResult.allowed) {
      throw new BusinessError(
        policyResult.message,
        policyResult.reason
      )
    }

    return { allowed: true }
  }
}
</file>

<file path="src/modules/credits/domain/entities/CreditTransaction.ts">
// src/modules/credits/domain/entities/CreditTransaction.ts

export enum CreditTransactionType {
  CREDIT = 'CREDIT', // adi√ß√£o de cr√©ditos
  DEBIT = 'DEBIT',   // consumo de cr√©ditos
}

export type CreditTransactionProps = {
  id?: string
  userId: string
  type: CreditTransactionType
  amount: number
  description?: string
  createdAt?: Date
  expiresAt?: Date | null
}

export class CreditTransaction {
  private readonly id?: string
  private readonly userId: string
  private readonly type: CreditTransactionType
  private readonly amount: number
  private readonly description?: string
  private readonly createdAt: Date
  private readonly expiresAt?: Date | null

  constructor(props: CreditTransactionProps) {
    if (props.amount <= 0) {
      throw new Error('Credit transaction amount must be greater than zero.')
    }

    this.id = props.id
    this.userId = props.userId
    this.type = props.type
    this.amount = props.amount
    this.description = props.description
    this.createdAt = props.createdAt ?? new Date()
    this.expiresAt = props.expiresAt ?? null
  }

  getId(): string | undefined {
    return this.id
  }

  getUserId(): string {
    return this.userId
  }

  getType(): CreditTransactionType {
    return this.type
  }

  getAmount(): number {
    return this.amount
  }

  getDescription(): string | undefined {
    return this.description
  }

  getCreatedAt(): Date {
    return this.createdAt
  }

  getExpiresAt(): Date | null {
    return this.expiresAt ?? null
  }

  isExpired(referenceDate: Date = new Date()): boolean {
    if (!this.expiresAt) return false

    return this.expiresAt.getTime() < referenceDate.getTime()
  }

  isCredit(): boolean {
    return this.type === CreditTransactionType.CREDIT
  }

  isDebit(): boolean {
    return this.type === CreditTransactionType.DEBIT
  }
}
</file>

<file path="src/modules/essays/application/useCases/GetEssayByIdUseCase.ts">
import { EssayRepository } from '../../ports/EssayRepository'
import { BusinessError } from '../../../shared/errors/BusinessError'
import { EssayMapper } from '../../infra/mappers/EssayMapper'

interface GetEssayByIdInput {
  essayId: string
  studentId: string
}

export class GetEssayByIdUseCase {
  constructor(
    private readonly essayRepository: EssayRepository
  ) {}

  async execute({ essayId, studentId }: GetEssayByIdInput) {
    const essay = await this.essayRepository.findById(essayId)

    if (!essay) {
      throw new BusinessError('Essay not found', 'NOT_FOUND')
    }

    if (essay.getStudentId() !== studentId) {
      throw new BusinessError(
        'You do not have access to this essay',
        'FORBIDDEN'
      )
    }

    return EssayMapper.toDetailsDTO(essay)
  }
}
</file>

<file path="src/modules/essays/application/useCases/SubmitEssayUseCase.ts">
import { Essay } from '../../domain/entities/Essay'
import { EssayRepository } from '../../ports/EssayRepository'
import { StorageService } from '../../ports/StorageService'
import { SubmitEssayDTO } from '../../dtos/SubmitEssayDTO'
import { EssayResponseDTO } from '../../dtos/EssayResponseDTO'

import { CheckUserCreditsUseCase } from '../../../credits/application/useCases/CheckUserCreditsUseCase'
import { CreditRepository } from '../../../credits/ports/CreditRepository'
import {
  CreditTransactionType,
} from '../../../credits/domain/entities/CreditTransaction'

import { BusinessError } from '../../../shared/errors/BusinessError'
import { TransactionManager } from '../../../shared/transactions/TransactionManager'

export class SubmitEssayUseCase {
  constructor(
    private readonly essayRepository: EssayRepository,
    private readonly storageService: StorageService,
    private readonly creditRepository: CreditRepository,
    private readonly checkUserCreditsUseCase: CheckUserCreditsUseCase,
    private readonly transactionManager: TransactionManager
  ) {}

  async execute(input: SubmitEssayDTO): Promise<EssayResponseDTO> {
    return this.transactionManager.run(async () => {
      // 1Ô∏è‚É£ Valida cr√©ditos (regra de neg√≥cio)
      await this.checkUserCreditsUseCase.execute({
        userId: input.studentId,
        planActive: true,
      })

      // 2Ô∏è‚É£ Persiste o arquivo
      const storedFile = await this.storageService.store({
        file: input.file,
        filename: `${input.studentId}-${Date.now()}.pdf`,
      })

      // 3Ô∏è‚É£ Cria entidade Essay
      const essay = Essay.create({
        studentId: input.studentId,
        theme: input.theme,
        fileUrl: storedFile.url,
      })

      // 4Ô∏è‚É£ Salva reda√ß√£o
      const savedEssay = await this.essayRepository.save(essay)

      // 5Ô∏è‚É£ Debita 1 cr√©dito
      await this.creditRepository.create({
        userId: input.studentId,
        type: CreditTransactionType.DEBIT,
        amount: 1,
        description: 'Envio de reda√ß√£o',
      })

      return {
        id: savedEssay.getId(),
        theme: savedEssay.getTheme(),
        status: savedEssay.getStatus(),
        createdAt: savedEssay.getCreatedAt(),
      }
    })
  }
}
</file>

<file path="src/modules/essays/domain/valueObjects/EssayStatus.ts">
export enum EssayStatus {
  SUBMITTED = 'SUBMITTED',
  IN_REVIEW = 'IN_REVIEW',
  CORRECTED = 'CORRECTED',
}
</file>

<file path="src/modules/essays/dtos/EssayResponseDTO.ts">
import { EssayStatus } from '../domain/valueObjects/EssayStatus'

export type EssayResponseDTO = {
  id?: string
  theme: string
  status: EssayStatus
  createdAt: Date
}
</file>

<file path="src/modules/essays/dtos/SubmitEssayDTO.ts">
export type SubmitEssayDTO = {
  studentId: string
  theme: string
  file: Buffer
}
</file>

<file path="src/modules/essays/infra/mappers/EssayMapper.ts">
import { Essay } from '../../domain/entities/Essay'
import { EssayDetailsDTO } from '../../dtos/EssayDetailsDTO'

export class EssayMapper {
  static toDetailsDTO(essay: Essay): EssayDetailsDTO {
    return {
      id: essay.getIdOrThrow(),
      theme: essay.getTheme(),
      status: essay.getStatus(),
      fileUrl: essay.getFileUrl(),
      createdAt: essay.getCreatedAt(),
    }
  }
}
</file>

<file path="src/modules/essays/infra/storage/LocalStorageService.ts">
import { StorageService, StoreFileInput, StoredFile } from '../../ports/StorageService'
import fs from 'fs'
import path from 'path'

export class LocalStorageService implements StorageService {
  private readonly basePath: string

  constructor() {
    this.basePath = path.resolve(process.cwd(), 'storage')

    if (!fs.existsSync(this.basePath)) {
      fs.mkdirSync(this.basePath, { recursive: true })
    }
  }

  async store(input: StoreFileInput): Promise<StoredFile> {
    const filePath = path.join(this.basePath, input.filename)

    await fs.promises.writeFile(filePath, input.file)

    return {
      url: `/storage/${input.filename}`,
    }
  }
}
</file>

<file path="src/modules/essays/ports/StorageService.ts">
export type StoreFileInput = {
  file: Buffer
  filename: string
}

export type StoredFile = {
  url: string
}

export interface StorageService {
  store(input: StoreFileInput): Promise<StoredFile>
}
</file>

<file path="src/modules/essays/presentation/index.ts">
import { PrismaEssayRepository } from '../infra/database/PrismaEssayRepository'
import { LocalStorageService } from '../infra/storage/LocalStorageService'
import { EssayController } from './controllers/EssayController'

import { SubmitEssayUseCase } from '../application/useCases/SubmitEssayUseCase'
import { GetEssayByIdUseCase } from '../application/useCases/GetEssayByIdUseCase'

import { PrismaCreditRepository } from '../../credits/infra/database/PrismaCreditRepository'
import { CreditPolicyService } from '../../credits/domain/services/CreditPolicyService'
import { CheckUserCreditsUseCase } from '../../credits/application/useCases/CheckUserCreditsUseCase'

import { PrismaTransactionManager } from '../../shared/transactions/PrismaTransactionManager'

import { createEssayRoutes } from './routes'

export function buildEssayModule() {
  // ======================
  // Infra
  // ======================
  const essayRepository = new PrismaEssayRepository()
  const storageService = new LocalStorageService()
  const creditRepository = new PrismaCreditRepository()
  const transactionManager = new PrismaTransactionManager()

  // ======================
  // Domain / Services
  // ======================
  const creditPolicyService = new CreditPolicyService()

  // ======================
  // Application / UseCases
  // ======================
  const checkUserCreditsUseCase = new CheckUserCreditsUseCase(
    creditRepository,
    creditPolicyService
  )

  const submitEssayUseCase = new SubmitEssayUseCase(
    essayRepository,
    storageService,
    creditRepository,
    checkUserCreditsUseCase,
    transactionManager
  )

  const getEssayByIdUseCase = new GetEssayByIdUseCase(
    essayRepository
  )

  // ======================
  // Controller
  // ======================
  const essayController = new EssayController(
    submitEssayUseCase,
    getEssayByIdUseCase
  )

  // ======================
  // Routes
  // ======================
  const routes = createEssayRoutes(essayController)

  return {
    routes,
  }
}
</file>

<file path="src/modules/health/presentation/controllers/HealthController.ts">
import { Request, Response } from "express";
import { successResponse } from "../../../shared/http/response";

export class HealthController {
  static check(req: Request, res: Response) {
    return successResponse(res, {
      status: "ok",
      uptime: process.uptime(),
      timestamp: new Date().toISOString()
    });
  }
}
</file>

<file path="src/modules/shared/database/prismaClient.ts">
import { PrismaClient } from '../../../generated/prisma'
import { PrismaPg } from '@prisma/adapter-pg'
import 'dotenv/config'

const adapter = new PrismaPg({
  connectionString: process.env.DATABASE_URL!,
})

export const prisma = new PrismaClient({
  adapter,
})
</file>

<file path="src/modules/shared/http/middlewares/error.middleware.ts">
import { Request, Response, NextFunction } from 'express'
import { BusinessError } from '../../errors/BusinessError'

export function errorMiddleware(
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
): Response {
  // üî¥ BusinessError (regra de neg√≥cio)
  if (error instanceof BusinessError) {
    const statusMap: Record<string, number> = {
      FORBIDDEN: 403,
      NOT_FOUND: 404,
      BAD_REQUEST: 400,
    }

    const status =
      (error.code && statusMap[error.code]) || 400

    return res.status(status).json({
      message: error.message,
      code: error.code,
    })
  }

  // üî• Erro inesperado
  console.error(error)

  return res.status(500).json({
    message: 'Internal server error',
  })
}
</file>

<file path="src/modules/shared/transactions/TransactionManager.ts">
export interface TransactionManager {
  run<T>(callback: () => Promise<T>): Promise<T>
}
</file>

<file path="src/tests/integration/credits.routes.spec.ts">
describe('SubmitEssayUseCase', () => {
  it('dummy test (placeholder)', () => {
    expect(true).toBe(true)
  })
})
</file>

<file path="src/tests/integration/essays.routes.spec.ts">
import request from 'supertest'
import app from '../../app'
import { prisma } from '../../modules/shared/database/prismaClient'
import { EssayStatus } from '../../modules/essays/domain/valueObjects/EssayStatus'

describe('Essays Routes (integration)', () => {
  const studentId = 'student-id-1'
  const essayId = 'essay-id-123'

  beforeAll(async () => {
    await prisma.essay.deleteMany()

    await prisma.essay.create({
      data: {
        id: essayId,
        studentId,
        theme: 'Tema integra√ß√£o',
        fileUrl: 'file.pdf',
        status: EssayStatus.SUBMITTED,
      },
    })
  })

  afterAll(async () => {
    await prisma.essay.deleteMany()
    await prisma.$disconnect()
  })

  it('GET /api/essays/:id should return essay details', async () => {
    const response = await request(app)
      .get(`/api/essays/${essayId}`)
      .query({ studentId })

    expect(response.status).toBe(200)
    expect(response.body).toEqual({
      id: essayId,
      theme: 'Tema integra√ß√£o',
      status: EssayStatus.SUBMITTED,
      fileUrl: 'file.pdf',
      createdAt: expect.any(String),
    })
  })

  it('GET /api/essays/:id should return 403 if essay does not belong to student', async () => {
    const response = await request(app)
      .get(`/api/essays/${essayId}`)
      .query({ studentId: 'other-student' })

    expect(response.status).toBe(403)
  })

  it('GET /api/essays/:id should return 404 if essay does not exist', async () => {
    const response = await request(app)
      .get('/api/essays/non-existing-id')
      .query({ studentId })

    expect(response.status).toBe(404)
  })
})
</file>

<file path="src/tests/unit/credits/AddCreditsUseCase.spec.ts">
describe('SubmitEssayUseCase', () => {
  it('dummy test (placeholder)', () => {
    expect(true).toBe(true)
  })
})
</file>

<file path="src/tests/unit/essays/SubmitEssayUseCase.spec.ts">
describe('SubmitEssayUseCase', () => {
  it('dummy test (placeholder)', () => {
    expect(true).toBe(true)
  })
})
</file>

<file path="src/modules/credits/domain/services/CreditPolicyService.ts">
// src/modules/credits/domain/services/CreditPolicyService.ts

export enum CreditBlockReason {
  INSUFFICIENT_CREDITS = 'INSUFFICIENT_CREDITS',
  CREDITS_EXPIRED = 'CREDITS_EXPIRED',
  PLAN_INACTIVE = 'PLAN_INACTIVE',
}

export type CreditPolicyInput = {
  availableCredits: number
  creditExpirationDate: Date | null
  planActive: boolean
}

export type CreditPolicyResult =
  | {
      allowed: true
      message: string
    }
  | {
      allowed: false
      reason: CreditBlockReason
      message: string
    }

export class CreditPolicyService {
  private static readonly CREDITS_REQUIRED_PER_ESSAY = 1

  evaluate(input: CreditPolicyInput): CreditPolicyResult {
    const {
      availableCredits,
      creditExpirationDate,
      planActive,
    } = input

    // 1Ô∏è‚É£ Plano inativo
    if (!planActive) {
      return {
        allowed: false,
        reason: CreditBlockReason.PLAN_INACTIVE,
        message:
          'Seu plano est√° inativo. Regularize ou realize um upgrade para continuar.',
      }
    }

    // 2Ô∏è‚É£ Cr√©ditos expirados
    if (
      creditExpirationDate &&
      creditExpirationDate.getTime() < Date.now()
    ) {
      return {
        allowed: false,
        reason: CreditBlockReason.CREDITS_EXPIRED,
        message:
          'Seus cr√©ditos expiraram. Fa√ßa um upgrade de plano para continuar.',
      }
    }

    // 3Ô∏è‚É£ Saldo insuficiente
    if (
      availableCredits <
      CreditPolicyService.CREDITS_REQUIRED_PER_ESSAY
    ) {
      return {
        allowed: false,
        reason: CreditBlockReason.INSUFFICIENT_CREDITS,
        message:
          'Voc√™ n√£o possui cr√©ditos suficientes para enviar uma reda√ß√£o.',
      }
    }

    // ‚úÖ Tudo ok
    return {
      allowed: true,
      message:
        'Cr√©dito validado com sucesso. Envio de reda√ß√£o liberado.',
    }
  }
}
</file>

<file path="src/modules/credits/infra/database/PrismaCreditRepository.ts">
import { prisma } from '../../../shared/database/prismaClient'
import {
  CreditRepository,
  CreateCreditTransactionParams,
} from '../../ports/CreditRepository'
import {
  CreditTransaction,
  CreditTransactionType,
} from '../../domain/entities/CreditTransaction'

export class PrismaCreditRepository implements CreditRepository {
  async findByUserId(userId: string): Promise<CreditTransaction[]> {
    const transactions = await prisma.creditTransaction.findMany({
      where: { userId },
      orderBy: { createdAt: 'asc' },
    })

    return transactions.map(
      (tx) =>
        new CreditTransaction({
          id: tx.id,
          userId: tx.userId,
          type: tx.type as CreditTransactionType,
          amount: tx.amount,
          description: tx.description ?? undefined,
          createdAt: tx.createdAt,
          expiresAt: tx.expiresAt,
        })
    )
  }

  async create(
    params: CreateCreditTransactionParams
  ): Promise<CreditTransaction> {
    const transaction = await prisma.creditTransaction.create({
      data: {
        userId: params.userId,
        type: params.type,
        amount: params.amount,
        description: params.description,
        expiresAt: params.expiresAt ?? null,
      },
    })

    return new CreditTransaction({
      id: transaction.id,
      userId: transaction.userId,
      type: transaction.type as CreditTransactionType,
      amount: transaction.amount,
      description: transaction.description ?? undefined,
      createdAt: transaction.createdAt,
      expiresAt: transaction.expiresAt,
    })
  }

  async getAvailableBalance(userId: string): Promise<number> {
    const transactions = await prisma.creditTransaction.findMany({
      where: {
        userId,
        OR: [
          { expiresAt: null },
          { expiresAt: { gt: new Date() } },
        ],
      },
    })

    return transactions.reduce((balance, tx) => {
      if (tx.type === CreditTransactionType.CREDIT) {
        return balance + tx.amount
      }
      if (tx.type === CreditTransactionType.DEBIT) {
        return balance - tx.amount
      }
      return balance
    }, 0)
  }

  async getUserCreditStatus(userId: string): Promise<{
    availableCredits: number
    creditExpirationDate: Date | null
  }> {
    const transactions = await prisma.creditTransaction.findMany({
      where: { userId },
    })

    const validTransactions = transactions.filter(
      (tx) => !tx.expiresAt || tx.expiresAt > new Date()
    )

    const availableCredits = validTransactions.reduce(
      (balance, tx) => {
        if (tx.type === CreditTransactionType.CREDIT) {
          return balance + tx.amount
        }
        if (tx.type === CreditTransactionType.DEBIT) {
          return balance - tx.amount
        }
        return balance
      },
      0
    )

    const creditExpirationDate =
      validTransactions
        .filter((tx) => tx.expiresAt !== null)
        .sort(
          (a, b) =>
            a.expiresAt!.getTime() - b.expiresAt!.getTime()
        )[0]?.expiresAt ?? null

    return {
      availableCredits,
      creditExpirationDate,
    }
  }

  async invalidateExpiredCredits(): Promise<void> {
    await prisma.creditTransaction.updateMany({
      where: {
        expiresAt: { lt: new Date() },
      },
      data: {
        amount: 0,
      },
    })
  }
}
</file>

<file path="src/modules/credits/ports/CreditRepository.ts">
// src/modules/credits/ports/CreditRepository.ts

import {
  CreditTransaction,
  CreditTransactionType,
} from '../domain/entities/CreditTransaction'

export type CreateCreditTransactionParams = {
  userId: string
  type: CreditTransactionType
  amount: number
  description?: string
  expiresAt?: Date | null
}

export interface CreditRepository {
  findByUserId(userId: string): Promise<CreditTransaction[]>

  create(
    params: CreateCreditTransactionParams
  ): Promise<CreditTransaction>

  getAvailableBalance(userId: string): Promise<number>

  invalidateExpiredCredits(): Promise<void>

  // üëá NECESS√ÅRIO PARA A POLICY
  getUserCreditStatus(userId: string): Promise<{
    availableCredits: number
    creditExpirationDate: Date | null
  }>
}
</file>

<file path="src/modules/essays/domain/entities/Essay.ts">
import { EssayStatus } from '../valueObjects/EssayStatus'

type EssayProps = {
  studentId: string
  theme: string
  fileUrl: string
}

export class Essay {
  private id?: string
  private readonly studentId: string
  private readonly theme: string
  private readonly fileUrl: string
  private status: EssayStatus
  private readonly createdAt: Date

  private constructor(
    props: EssayProps,
    id?: string,
    createdAt?: Date
  ) {
    this.id = id
    this.studentId = props.studentId
    this.theme = props.theme
    this.fileUrl = props.fileUrl
    this.status = EssayStatus.SUBMITTED
    this.createdAt = createdAt ?? new Date()
  }

  /**
   * Cria√ß√£o de uma nova reda√ß√£o (antes de persistir)
   */
  static create(props: EssayProps): Essay {
    return new Essay(props)
  }

  /**
   * Reconstitui√ß√£o de uma reda√ß√£o j√° persistida
   */
  static restore(
    props: EssayProps,
    id: string,
    status: EssayStatus,
    createdAt: Date
  ): Essay {
    const essay = new Essay(props, id, createdAt)
    essay.status = status
    return essay
  }

  /**
   * ID pode ser indefinido antes da persist√™ncia
   */
  getId(): string | undefined {
    return this.id
  }

  /**
   * ID garantido (somente ap√≥s persist√™ncia)
   */
  getIdOrThrow(): string {
    if (!this.id) {
      throw new Error('Essay ID not defined')
    }

    return this.id
  }

  getTheme(): string {
    return this.theme
  }

  getStatus(): EssayStatus {
    return this.status
  }

  getCreatedAt(): Date {
    return this.createdAt
  }

  getStudentId(): string {
    return this.studentId
  }

  getFileUrl(): string {
    return this.fileUrl
  }
}
</file>

<file path="src/modules/essays/infra/database/PrismaEssayRepository.ts">
import { prisma } from '../../../shared/database/prismaClient'
import { Essay } from '../../domain/entities/Essay'
import { EssayRepository } from '../../ports/EssayRepository'
import { EssayStatus } from '../../domain/valueObjects/EssayStatus'

export class PrismaEssayRepository implements EssayRepository {
  async save(essay: Essay): Promise<Essay> {
    const created = await prisma.essay.create({
      data: {
        studentId: essay.getStudentId(),
        theme: essay.getTheme(),
        fileUrl: essay.getFileUrl(),
        status: EssayStatus.SUBMITTED,
      },
    })

    return Essay.restore(
      {
        theme: created.theme,
        fileUrl: created.fileUrl,
        studentId: created.studentId,
      },
      created.id,
      created.status as EssayStatus,
      created.createdAt
    )
  }

  async findById(id: string): Promise<Essay | null> {
    const found = await prisma.essay.findUnique({
      where: { id },
    })

    if (!found) {
      return null
    }

    return Essay.restore(
      {
        theme: found.theme,
        fileUrl: found.fileUrl,
        studentId: found.studentId,
      },
      found.id,
      found.status as EssayStatus,
      found.createdAt
    )
  }

  async findByStudent(params: {
    studentId: string
    page: number
    limit: number
    status?: EssayStatus
  }): Promise<{ items: Essay[]; total: number }> {
    const { studentId, page, limit, status } = params

    const where = {
      studentId,
      ...(status && { status }),
    }

    const [items, total] = await Promise.all([
      prisma.essay.findMany({
        where,
        skip: (page - 1) * limit,
        take: limit,
        orderBy: { createdAt: 'desc' },
      }),
      prisma.essay.count({ where }),
    ])

    return {
      items: items.map((essay) =>
        Essay.restore(
          {
            theme: essay.theme,
            fileUrl: essay.fileUrl,
            studentId: essay.studentId,
          },
          essay.id,
          essay.status as EssayStatus,
          essay.createdAt
        )
      ),
      total,
    }
  }
}
</file>

<file path="src/modules/essays/ports/EssayRepository.ts">
import { Essay } from '../domain/entities/Essay'
import { EssayStatus } from '../domain/valueObjects/EssayStatus'

export interface EssayRepository {
  /**
   * Persiste uma nova reda√ß√£o
   */
  save(essay: Essay): Promise<Essay>

  /**
   * Busca uma reda√ß√£o espec√≠fica pelo ID
   */
  findById(id: string): Promise<Essay | null>

  /**
   * Lista reda√ß√µes de um aluno com pagina√ß√£o e filtro opcional
   */
  findByStudent(params: {
    studentId: string
    page: number
    limit: number
    status?: EssayStatus
  }): Promise<{
    items: Essay[]
    total: number
  }>
}
</file>

<file path="src/modules/essays/presentation/controllers/EssayController.ts">
import { Request, Response, NextFunction } from 'express'
import { SubmitEssayUseCase } from '../../application/useCases/SubmitEssayUseCase'
import { GetEssayByIdUseCase } from '../../application/useCases/GetEssayByIdUseCase'

export class EssayController {
  constructor(
    private readonly submitEssayUseCase: SubmitEssayUseCase,
    private readonly getEssayByIdUseCase: GetEssayByIdUseCase
  ) {}

  async submit(
    req: Request,
    res: Response,
    next: NextFunction
  ): Promise<Response | void> {
    try {
      const { studentId, theme } = req.body
      const file = req.file

      if (!file) {
        return res.status(400).json({
          message: 'Arquivo da reda√ß√£o √© obrigat√≥rio.',
        })
      }

      const result = await this.submitEssayUseCase.execute({
        studentId,
        theme,
        file: file.buffer,
      })

      return res.status(201).json(result)
    } catch (error) {
      next(error)
    }
  }

  async getById(
  req: Request,
  res: Response,
  next: NextFunction
): Promise<Response | void> {
  try {
    const essayId = req.params.id
    const studentId = req.query.studentId as string

    const result = await this.getEssayByIdUseCase.execute({
      essayId,
      studentId,
    })

    return res.status(200).json(result)
  } catch (error) {
    next(error)
    }
  }

}
</file>

<file path="src/modules/essays/presentation/routes.ts">
import { Router } from 'express'
import multer from 'multer'
import { EssayController } from './controllers/EssayController'

const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 },
})

export function createEssayRoutes(
  essayController: EssayController
): Router {
  const routes = Router()

  routes.post(
    '/essays',
    upload.single('file'),
    (req, res, next) => essayController.submit(req, res, next)
  )

  routes.get(
    '/essays/:id',
    (req, res, next) => essayController.getById(req, res, next)
  )

  return routes
}
</file>

<file path="src/modules/shared/errors/BusinessError.ts">
export class BusinessError extends Error {
  public readonly code?: string

  constructor(message: string, code: string) {
    super(message)
    this.name = 'BusinessError'
    this.code = code

    Object.setPrototypeOf(this, BusinessError.prototype)
  }
}
</file>

<file path="estrutura.txt">
src/
‚îî‚îÄ‚îÄ main/
    ‚îú‚îÄ‚îÄ app.ts
    ‚îú‚îÄ‚îÄ server.ts
    ‚îú‚îÄ‚îÄ routes.ts

‚îî‚îÄ‚îÄ modules/
    ‚îú‚îÄ‚îÄ essays/                         # n√∫cleo do produto
    ‚îÇ   ‚îú‚îÄ‚îÄ presentation/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ EssayController.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middlewares/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validateSubmitEssay.middleware.ts
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ idempotency.middleware.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes.ts
    ‚îÇ   |   ‚îî‚îÄ‚îÄ index.ts 
    |
    ‚îÇ   ‚îú‚îÄ‚îÄ application/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useCases/
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ SubmitEssayUseCase.ts
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ListEssaysUseCase.ts
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ GetEssayByIdUseCase.ts
    ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚îÄ dtos/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SubmitEssayDTO.ts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ EssayResponseDTO.ts
    ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚îÄ ports/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ EssayRepository.ts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StorageService.ts
    ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚îÄ domain/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Essay.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ WeeklyLimitService.ts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ valueObjects/
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ EssayStatus.ts
    ‚îÇ
    ‚îÇ   ‚îî‚îÄ‚îÄ infra/
    ‚îÇ       ‚îú‚îÄ‚îÄ database/
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ PrismaEssayRepository.ts
    ‚îÇ       ‚îú‚îÄ‚îÄ storage/
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ LocalStorageService.ts
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ S3StorageService.ts       # futuro
    ‚îÇ       ‚îî‚îÄ‚îÄ mappers/
    ‚îÇ           ‚îî‚îÄ‚îÄ EssayMapper.ts
    ‚îÇ
    ‚îú‚îÄ‚îÄ credits/                        # NOVO: regra de neg√≥cio
    ‚îÇ   ‚îú‚îÄ‚îÄ presentation/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreditAdminController.ts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes.ts
    ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚îÄ application/    
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useCases/
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ AddCreditsUseCase.ts
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ RemoveCreditsUseCase.ts
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ToggleInfiniteCreditsUseCase.ts
    ‚îÇ   |       ‚îî‚îÄ‚îÄ CheckUserCreditsUseCase.ts
    |
    ‚îÇ   ‚îú‚îÄ‚îÄ domain/
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ entities/
    ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreditTransaction.ts
    ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îÇ   |   ‚îî‚îÄ‚îÄ CreditPolicyService.ts
    |   |   ‚îî‚îÄ‚îÄ errors
    ‚îÇ   |       ‚îî‚îÄ‚îÄ CreditBlockedError.ts
    |
    ‚îÇ   ‚îú‚îÄ‚îÄ ports/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreditRepository.ts
    ‚îÇ
    ‚îÇ   ‚îî‚îÄ‚îÄ infra/
    ‚îÇ       ‚îî‚îÄ‚îÄ database/
    ‚îÇ           ‚îî‚îÄ‚îÄ PrismaCreditRepository.ts
    ‚îÇ
    ‚îú‚îÄ‚îÄ users/
    ‚îÇ   ‚îú‚îÄ‚îÄ domain/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ entities/
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Student.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ ports/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ StudentRepository.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ infra/
    ‚îÇ       ‚îî‚îÄ‚îÄ database/
    ‚îÇ           ‚îî‚îÄ‚îÄ PrismaStudentRepository.ts
    ‚îÇ
    ‚îú‚îÄ‚îÄ health/
    ‚îÇ   ‚îú‚îÄ‚îÄ presentation/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ controllers/
    ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ HealthController.ts
    ‚îÇ   ‚îú‚îÄ‚îÄ application/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CheckHealthUseCase.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ routes.ts
    ‚îÇ
    ‚îú‚îÄ‚îÄ auth/                           # futuro (JWT, roles)
    ‚îÇ
    ‚îî‚îÄ‚îÄ shared/
        ‚îú‚îÄ‚îÄ config/
        ‚îÇ   ‚îú‚îÄ‚îÄ env.ts
        ‚îÇ   ‚îú‚îÄ‚îÄ cors.ts
        ‚îÇ   ‚îú‚îÄ‚îÄ helmet.ts
        ‚îÇ   ‚îî‚îÄ‚îÄ logger.ts
        ‚îÇ
        ‚îú‚îÄ‚îÄ database/
        ‚îÇ   ‚îî‚îÄ‚îÄ prismaClient.ts         # transa√ß√µes centralizadas
        ‚îÇ
        ‚îú‚îÄ‚îÄ errors/
        ‚îÇ   ‚îú‚îÄ‚îÄ AppError.ts
        ‚îÇ   ‚îú‚îÄ‚îÄ BusinessError.ts
        ‚îÇ   ‚îî‚îÄ‚îÄ ValidationError.ts
        ‚îÇ
        ‚îú‚îÄ‚îÄ http/
        ‚îÇ   ‚îú‚îÄ‚îÄ response.ts
        ‚îÇ   ‚îî‚îÄ‚îÄ middlewares/
        ‚îÇ       ‚îú‚îÄ‚îÄ error.middleware.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ rateLimit.middleware.ts
        ‚îÇ       ‚îî‚îÄ‚îÄ validation.middleware.ts
        ‚îÇ
        ‚îú‚îÄ‚îÄ transactions/
        ‚îÇ   ‚îî‚îÄ‚îÄ TransactionManager.ts   # abstra√ß√£o de $transaction
        |   ‚îî‚îÄ‚îÄ PrismaTransactionManager.ts
        ‚îÇ
        ‚îî‚îÄ‚îÄ utils/
            ‚îî‚îÄ‚îÄ sanitize.ts

‚îî‚îÄ‚îÄ routes/
    ‚îî‚îÄ‚îÄ index.ts

‚îî‚îÄ‚îÄ tests/
    ‚îú‚îÄ‚îÄ unit/
    ‚îÇ   ‚îú‚îÄ‚îÄ essays/
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SubmitEssayUseCase.spec.ts
    ‚îÇ   ‚îî‚îÄ‚îÄ credits/
    ‚îÇ       ‚îî‚îÄ‚îÄ AddCreditsUseCase.spec.ts
    ‚îÇ
    ‚îî‚îÄ‚îÄ integration/
        ‚îú‚îÄ‚îÄ essays.routes.spec.ts
        ‚îî‚îÄ‚îÄ credits.routes.spec.ts

‚îî‚îÄ‚îÄ index.ts
</file>

<file path="package.json">
{
  "name": "redatando",
  "version": "1.0.0",
  "description": "Backend do sistema web de corre√ß√£o de reda√ß√µes da Redatando",
  "main": "index.js",
  "type": "commonjs",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "build": "tsc",
    "start": "node dist/server.js",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@prisma/adapter-pg": "^7.3.0",
    "@prisma/client": "^7.3.0",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-rate-limit": "^7.3.0",
    "git": "^0.1.5",
    "helmet": "^7.1.0",
    "multer": "^2.0.2",
    "pg": "^8.17.2",
    "supertest": "^7.2.2"
  },
  "devDependencies": {
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jest": "^29.5.12",
    "@types/multer": "^2.0.0",
    "@types/node": "^20.19.30",
    "@types/supertest": "^6.0.3",
    "jest": "^29.7.0",
    "prisma": "^7.3.0",
    "ts-jest": "^29.1.2",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.4.5"
  }
}
</file>

<file path="ROADMAP.md">
# üó∫Ô∏è ROADMAP DO BACKEND ‚Äî REDATANDO

Este roadmap descreve a evolu√ß√£o do **backend do sistema web de corre√ß√£o de reda√ß√µes da Redatando**.  
Ele reflete o **estado real atual do projeto**, alinhado a uma **Clean Architecture pragm√°tica**, focada em regras de neg√≥cio, seguran√ßa e escalabilidade.

---

## üß± FASE 0 ‚Äî Prepara√ß√£o (Base do Projeto) ‚úÖ CONCLU√çDA

üéØ **Objetivo**  
Garantir que o backend suba sem erro e siga um padr√£o profissional desde o in√≠cio.

### Atividades
- [x] Inicializar projeto Node.js + TypeScript
- [x] Configurar `tsconfig.json` (Node16 + resolu√ß√£o correta)
- [x] Criar `.env` e `.env.example`
- [x] Criar estrutura inicial de pastas (`modules`, `shared`, `routes`)
- [x] Configurar scripts (`dev`, `build`, `start`)
- [x] Criar endpoint de health check (`/health`)

### Crit√©rio de pronto
- [x] `npm run dev` sobe sem erros
- [x] Endpoint `/health` responde `200 OK`

---

## üîê FASE 1 ‚Äî Seguran√ßa Estrutural ‚úÖ CONCLU√çDA
**(ANTES de qualquer feature de neg√≥cio)**

üéØ **Objetivo**  
Blindar o backend contra erros comuns e falhas b√°sicas de seguran√ßa desde o dia 1.

### Atividades
- [x] Configurar Helmet (headers seguros)
- [x] Configurar CORS
- [x] Rate limit global
- [x] Middleware de erro centralizado
- [x] Logger b√°sico
- [x] Sanitiza√ß√£o de input

### Crit√©rio de pronto
- [x] Erros tratados em um √∫nico lugar
- [x] Nenhuma rota exp√µe stack trace
- [x] Rate limit ativo e funcional

---

## üß© FASE 2 ‚Äî Base da API (Contrato HTTP) ‚úÖ CONCLU√çDA

üéØ **Objetivo**  
Definir claramente como o frontend se comunica com o backend.

### Atividades
- [x] Estrutura base de rotas
- [x] Controllers padronizados
- [x] DTOs
- [x] Middleware de valida√ß√£o de payload
- [x] Padr√£o √∫nico de resposta (`success / error`)

### Crit√©rio de pronto
- [x] API responde sempre no mesmo formato
- [x] Payload inv√°lido √© bloqueado antes do controller

---

## üóÑÔ∏è FASE 3 ‚Äî Banco de Dados & Persist√™ncia ‚úÖ CONCLU√çDA

üéØ **Objetivo**  
Persistir dados reais sem acoplamento com a camada HTTP.

### Atividades
- [x] Escolha do ORM (Prisma)
- [x] Conex√£o com PostgreSQL
- [x] Sistema de migrations
- [x] Repositories desacoplados
- [x] Prisma Client configurado corretamente (v7)
- [x] Schemas iniciais:
  - [x] `Essay`
  - [x] `Content`
  - [x] `CreditTransaction`

### Crit√©rio de pronto
- [x] CRUD funcional
- [x] Migrations versionadas
- [x] Banco acessado apenas via repositories

---

## üí≥ FASE 4 ‚Äî Sistema de Cr√©ditos (Regra de Neg√≥cio Central) ‚úÖ CONCLU√çDA

üéØ **Objetivo**  
Implementar um sistema robusto de cr√©ditos baseado em **ledger (transa√ß√µes)**.

### Atividades
- [x] Entity `CreditTransaction`
- [x] Enum `CREDIT / DEBIT`
- [x] `CreditPolicyService`
- [x] C√°lculo de saldo via soma de transa√ß√µes
- [x] Bloqueio de a√ß√µes sem cr√©dito
- [x] Registro autom√°tico de d√©bito
- [x] Transa√ß√µes audit√°veis (sem campo `balance`)

### Crit√©rio de pronto
- [x] Envio bloqueado sem cr√©dito
- [x] Cr√©dito consumido automaticamente
- [x] Saldo sempre consistente

---

## üìù FASE 5 ‚Äî Envio de Reda√ß√µes (Core do Produto) ‚úÖ CONCLU√çDA

üéØ **Objetivo**  
Permitir que alunos enviem reda√ß√µes com seguran√ßa e regras bem definidas.

### Atividades
- [x] Upload multipart (`multer`)
- [x] Valida√ß√£o de campos obrigat√≥rios
- [x] Verifica√ß√£o de cr√©dito ANTES do upload
- [x] Persist√™ncia da reda√ß√£o
- [x] Storage local
- [x] Uso de transa√ß√£o (essay + debit)
- [x] Status inicial (`SUBMITTED`)

### Crit√©rio de pronto
- [x] Upload inv√°lido √© bloqueado
- [x] Reda√ß√£o s√≥ √© enviada com cr√©dito
- [x] Fluxo validado end-to-end via Postman

---

## üìÇ FASE 6 ‚Äî Consulta & Gest√£o de Reda√ß√µes (Pr√≥xima) ‚úÖ CONCLU√çDA

üéØ **Objetivo**  
Permitir visualizar e gerenciar reda√ß√µes enviadas.

### Atividades
- [x] Listar reda√ß√µes do aluno
- [x] Buscar reda√ß√£o por ID
- [x] Pagina√ß√£o
- [x] Filtro por status
- [x] DTOs de resposta adequados

---

## üîê FASE 7 ‚Äî Autentica√ß√£o & Autoriza√ß√£o

üéØ **Objetivo**  
Preparar o sistema para m√∫ltiplos perfis e acesso seguro.

### Atividades
- [ ] JWT (base)
- [ ] Identidade do usu√°rio (student / admin)
- [ ] Prote√ß√£o de rotas
- [ ] Separa√ß√£o de permiss√µes
- [ ] Middleware de auth

---

## üß™ FASE 8 ‚Äî Testes & Qualidade

üéØ **Objetivo**  
Garantir estabilidade e evitar regress√µes.

### Atividades
- [ ] Testes unit√°rios (use cases)
- [ ] Testes de integra√ß√£o (rotas)
- [ ] Testes de cen√°rios de erro
- [ ] Coverage m√≠nimo aceit√°vel

---

## üìò FASE 9 ‚Äî Documenta√ß√£o & Produ√ß√£o

üéØ **Objetivo**  
Deixar o backend pronto para apresenta√ß√£o e deploy.

### Atividades
- [ ] Swagger / OpenAPI
- [ ] README t√©cnico profissional
- [ ] Ajustes de build
- [ ] Configura√ß√£o segura de ambiente
- [ ] Checklist de deploy

---

## üß† VIS√ÉO ESTRAT√âGICA

- Sistema baseado em **regras de neg√≥cio reais**
- Cr√©ditos implementados como **ledger audit√°vel**
- Arquitetura preparada para:
  - planos mensais
  - corre√ß√£o autom√°tica
  - m√∫ltiplos corretores
- Projeto utiliz√°vel como:
  - portf√≥lio
  - base comercial
  - argumento t√©cnico em entrevistas

---

## üèÅ STATUS ATUAL

üü¢ **Core do produto totalmente funcional e validado**  
üü° Pr√≥ximo foco: **consulta, auth e documenta√ß√£o**
</file>

<file path="src/app.ts">
import express from 'express'
import cors from 'cors'
import helmet from 'helmet'

import routes from './routes'

import { rateLimitMiddleware } from './modules/shared/http/middlewares/rateLimit.middleware'
import { errorMiddleware } from './modules/shared/http/middlewares/error.middleware'
import { sanitizeMiddleware } from './modules/shared/http/middlewares/validation.middleware'

const app = express()

// ============================
// Global middlewares
// ============================
app.use(helmet())
app.use(cors())
app.use(express.json())

app.use(rateLimitMiddleware)
app.use(sanitizeMiddleware)

// ============================
// Routes
// ============================
app.use('/api', routes)

// ============================
// Error handler (always last)
// ============================
app.use(errorMiddleware)

export default app
</file>

<file path="src/routes/index.ts">
import { Router } from 'express'
import { buildEssayModule } from '../modules/essays/presentation'

const routes = Router()

// ============================
// Modules
// ============================
const essayModule = buildEssayModule()
routes.use(essayModule.routes)

export default routes
</file>

<file path="src/server.ts">
import app from './app'

const PORT = process.env.PORT || 3000

app.listen(PORT, () => {
  console.log(`üöÄ Server running on http://localhost:${PORT}`)
})
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2021",
    "module": "Node16",
    "moduleResolution": "node16",

    "rootDir": "./src",
    "outDir": "./dist",

    "isolatedModules": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,

    "esModuleInterop": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,

    "sourceMap": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "src/tests"]
}
</file>

</files>
